# Appsmith Architecture

Getting started on the Appsmith platform is quick and secure, available via the [cloud]((http://app.appsmith.com/user/sign-up)) as well as [self-hosted](/getting-started/setup#self-hosted) instances. Both versions are extremely similar in features and architecture, deployed as a single Docker container with a single volume for storing persistent data. With a [single line of code](/getting-started/setup/installation-guides/docker#setup-with-docker-run) or a one-click interaction via the AWS or DigitalOcean Marketplace or Heroku, Appsmith can be installed and put to use.

Read further to learn about how the platform is organized, built, and deployed.

## Self-hosted instance architecture

The diagram below illustrates how the different pieces of the platform relate to each other:

![Appsmith Deployment Architecture](/img/Appsmith_Deployment_Architecture.png)

## How it works

A single Docker container runs the following processes to deploy and get started with Appsmith:

1. The **backend server** as a Java process, which handles:
    1. Authentication: username and password, OAuth 2.0 with Google and GitHub, SSO with OIDC and SAML
    2. A CRUD API for users, workspaces, applications, pages, widgets
    3. An action execution module that executes your queries to your databases and APIs
    4. A git module that maintains clones of your Git-connected apps on the file system.

2. The **NGINX server**, which routes:
    1. Requests to static assets like Javascript, CSS, and images
    2. Incoming requests to the backend server, or the RTS depending on the request path
    3. Path-unidentified requests to an `index.html` page with a 200 status code. This is like a typical single-page application where the client React code is expected to understand the path and show the UI accordingly.

3. The **Real Time Service (RTS)**, a tiny NodeJS server that handles a few features such as mapping dependencies between APIs, queries, and web UI components. It also updates references for all reference-able entities when their names change in Appsmith.

4. The **MongoDB server**, which stores all persistent data needed and generated by Appsmith’s building blocks, like:
    1. Your users’ details and permissions
    2. Workspaces you have created
    3. Applications you are building and have deployed
    4. Datasources you have connected to
    5. Queries that connect those datasources to your apps.

5. The **Redis server**, which is used for storing user sessions and cache permissions that a user has access to directly and indirectly.

## Process management

To manage the processes needed to function, Appsmith uses [Supervisor](http://supervisord.org/). This is a lightweight process manager that, when given a list of things to run, runs them, restarts them if they crash, and collects their logs for maintenance and debugging.

When you run the Docker command to start the Appsmith container, it identifies which processes are required to start and run. This includes the backend server, the RTS, and the NGINX server -- as well as any additional processes that haven't been plugged in by the user externally, such as a custom MongoDB or Redis instance.

For each of these processes, the container’s entry-point script (the one that Docker invokes when the container starts) generates a config file with all the details needed for supervisord. For example, the config file generated for the backend Java server includes the full set of commands for starting the process, as well as all necessary environment variables and settings. This same entry-point script also helps set up SSL certificates and install custom CA roots.

Supervisord also comes with a command line tool that you can use to control these processes individually. For example, you can run `supervisorctl restart redis` if you want to restart the Redis process. Or, as another example, the `Save and Restart` button under `Admin Settings` on the Appsmith UI is powered the `supervisorctl` tool; clicking that button after you make changes with the UI prompts the backend server to execute `supervisorctl restart backend`, which restarts the backend process.

### Docker

Appsmith runs as a single Docker container, housing all five processes in one image via Supervisord.

As described above in [process management](#process-management), this configuration provides flexibility in how you set up your Appsmith instance. Appsmith can take care of the entire batch of processes on its own, or you can choose to [drop in your own custom elements](/getting-started/setup/instance-configuration/custom-mongodb-redis) like MongoDB or Redis by modifying environment variables.

### Kubernetes

Kubernetes is an open source software used to manage and scale wide deployments of applications in containers; Appsmith Cloud runs on geographically distanced Kubernetes clusters via AWS. This deployment strategy allows the Appsmith Cloud platform to be scale and avoid downtime during outages, as well as conduct rolling updates with minimal disruptions to service.

If you choose to [deploy Appsmith on Kubernetes](https://docs.appsmith.com/getting-started/setup/installation-guides/kubernetes), the only solution is to use our [official Helm chart](https://helm.appsmith.com). This Helm chart manages MongoDB and Redis as separate [Kubernetes pods](https://kubernetes.io/docs/concepts/workloads/pods/) so your Appsmith instances can scale horizontally. As before, this method also allows you the option to use external MongoDB and Redis instances that you manage on your own.